---
title: "Differential Equation Model of a Chemostat"
author: "Thomas Petzoldt"
date: "February 1, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

The example shows a chemostat model by example of autotrophic organisms (Algae, $Alg$), where growth is limited by a single nutrient (phosphorus, $P$) via a Monod equation.

## Implementation

The system is solved numerically with solvers from package **deSolve** @Soetaert2010, while equilibria at infinite time are estimated with package **rootSolve** @Soetaert2009. The implementation follows the standard formulation of these packages, see package vignette and @Soetaert_rjournal for details.

```{r, chemostat}
library("deSolve")
library("rootSolve")

chemostat <- function(time, init, parms) {
  with(as.list(c(init, parms)), {
    mu   <- mumax * P/(kp + P)  # Monod equation
    dAlg <- mu * Alg - D * Alg
    dP   <-  D *(P0 - P) - 1/Y * mu * Alg
    list(c(dAlg, dP), mu=mu)
   })
}
parms <- c(
  mumax = 0.5,    # 1/d
  kp    = 0.01,   # half saturation constant (mg/L)
  Y     = 41,     # yield coefficient (stoichiometric C:P ratio)
  D     = 0.1,    # 1/d
  P0    = 0.05    # P in inflow (mg/L)
)
times <- seq(0, 40, 0.1)  # (d)
init  <- c(Alg=0.01, P=0.05) # Phytoplankton C and Phosphorus P (mg/L)
```

## Dynamic simulation

A dynamic simulation can then be performed by function `ode`, using the default algorithm `lsoda` with automatic integration step size. The result (`out`) is then a matrix-like object of class `deSolve` that is supported by a generic (i.e. object oriented) plot function.

```{r, single}
out <- ode(init, times, chemostat, parms)
plot(out)
```

The plot function allows also to show several scenarios simultanaeously:

```{r, multiple}
init  <- c(Alg=1.0, P=0.05)
p1 <- p2 <- p3 <- parms
p1["D"] <- 0; p2["D"] <- 0.3; p3["D"] <- 0.5
out <- ode(init, times, chemostat, parms)
out1 <- ode(init, times, chemostat, p1)
out2 <- ode(init, times, chemostat, p2)
out3 <- ode(init, times, chemostat, p3)

plot(out, out1, out2, out3, which=c("Alg", "P"))
```

## Steady State

The equilibrium can be aproximated numerically with package **rootSolve**. 
We use a loop here for simplicity, even if list-based approaches (e.g. `lapply`) 
may appear as more elegant for the intermediate and advanced **R** user.

```{r, steadystate}
state <- data.frame(
  D = seq(0, 0.6, length.out = 100),
  X = 0,
  S = 0
)

init  <- c(Alg=0.01, P=0.05) 

for (i in 1:nrow(state)) {
  parms["D"] <- state$D[i]
  times <- c(0, Inf)
  out <- runsteady(init, times, chemostat, parms)
  state[i, 2:3] <- out$y
}

par(mfrow = c(1, 3))
plot(S ~ D, data = state, type = "l")
plot(X ~ D, data = state, type = "l")
plot(S * X ~ D, data = state, type = "l")
```

